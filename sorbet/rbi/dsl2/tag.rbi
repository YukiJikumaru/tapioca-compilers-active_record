# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for dynamic methods in `Tag`.
# Please instead update this file by running `bin/tapioca dsl Tag`.

class Tag
  include ::Tag::GeneratedAttributeMethods

  module ::Tag::GeneratedAttributeMethods
    sig { returns(T.untyped) }
    def clear_created_at_change; end

    sig { returns(T.untyped) }
    def clear_id_change; end

    sig { returns(T.untyped) }
    def clear_name_change; end

    sig { returns(T.untyped) }
    def clear_slug_change; end

    sig { returns(T.untyped) }
    def clear_updated_at_change; end

    # test
    sig { returns(::ActiveSupport::TimeWithZone) }
    def created_at; end

    # test
    sig { params(value: ::ActiveSupport::TimeWithZone).returns(::ActiveSupport::TimeWithZone) }
    def created_at=(value); end

    sig { returns(T::Boolean) }
    def created_at?; end

    sig { returns(T.nilable(::ActiveSupport::TimeWithZone)) }
    def created_at_before_last_save; end

    sig { returns(::ActiveSupport::TimeWithZone) }
    def created_at_before_type_cast; end

    sig { returns(T::Boolean) }
    def created_at_came_from_user?; end

    sig { returns(T.nilable([T.nilable(::ActiveSupport::TimeWithZone), T.nilable(::ActiveSupport::TimeWithZone)])) }
    def created_at_change; end

    sig { returns(T.nilable([T.nilable(::ActiveSupport::TimeWithZone), T.untyped])) }
    def created_at_change_to_be_saved; end

    sig { returns(::ActiveSupport::TimeWithZone) }
    def created_at_for_database; end

    sig { returns(::ActiveSupport::TimeWithZone) }
    def created_at_in_database; end

    sig { returns(T.nilable([T.nilable(::ActiveSupport::TimeWithZone), T.nilable(::ActiveSupport::TimeWithZone)])) }
    def created_at_previous_change; end

    sig do
      params(
        from: T.nilable(::ActiveSupport::TimeWithZone),
        to: T.nilable(::ActiveSupport::TimeWithZone)
      ).returns(T::Boolean)
    end
    def created_at_previously_changed?(from: nil, to: nil); end

    sig { returns(T.nilable(::ActiveSupport::TimeWithZone)) }
    def created_at_previously_was; end

    sig { returns(T.nilable(::ActiveSupport::TimeWithZone)) }
    def created_at_was; end

    sig { returns(T.untyped) }
    def created_at_will_change!; end

    sig { returns(T::Boolean) }
    def created_atchanged?; end

    # test
    sig { returns(::Integer) }
    def id; end

    # test
    sig { params(value: ::Integer).returns(::Integer) }
    def id=(value); end

    sig { returns(T::Boolean) }
    def id?; end

    sig { returns(T.nilable(::Integer)) }
    def id_before_last_save; end

    sig { returns(::Integer) }
    def id_before_type_cast; end

    sig { returns(T::Boolean) }
    def id_came_from_user?; end

    sig { returns(T.nilable([T.nilable(::Integer), T.nilable(::Integer)])) }
    def id_change; end

    sig { returns(T.nilable([T.nilable(::Integer), T.untyped])) }
    def id_change_to_be_saved; end

    sig { returns(::Integer) }
    def id_for_database; end

    sig { returns(::Integer) }
    def id_in_database; end

    sig { returns(T.nilable([T.nilable(::Integer), T.nilable(::Integer)])) }
    def id_previous_change; end

    sig { params(from: T.nilable(::Integer), to: T.nilable(::Integer)).returns(T::Boolean) }
    def id_previously_changed?(from: nil, to: nil); end

    sig { returns(T.nilable(::Integer)) }
    def id_previously_was; end

    sig { returns(T.nilable(::Integer)) }
    def id_was; end

    sig { returns(T.untyped) }
    def id_will_change!; end

    sig { returns(T::Boolean) }
    def idchanged?; end

    # test
    sig { returns(T.untyped) }
    def name; end

    # test
    sig { params(value: T.untyped).returns(T.untyped) }
    def name=(value); end

    sig { returns(T::Boolean) }
    def name?; end

    sig { returns(T.untyped) }
    def name_before_last_save; end

    sig { returns(T.untyped) }
    def name_before_type_cast; end

    sig { returns(T::Boolean) }
    def name_came_from_user?; end

    sig { returns(T.nilable([T.untyped, T.untyped])) }
    def name_change; end

    sig { returns(T.nilable([T.untyped, T.untyped])) }
    def name_change_to_be_saved; end

    sig { returns(T.untyped) }
    def name_for_database; end

    sig { returns(T.untyped) }
    def name_in_database; end

    sig { returns(T.nilable([T.untyped, T.untyped])) }
    def name_previous_change; end

    sig { params(from: T.untyped, to: T.untyped).returns(T::Boolean) }
    def name_previously_changed?(from: nil, to: nil); end

    sig { returns(T.untyped) }
    def name_previously_was; end

    sig { returns(T.untyped) }
    def name_was; end

    sig { returns(T.untyped) }
    def name_will_change!; end

    sig { returns(T::Boolean) }
    def namechanged?; end

    sig { returns(T.untyped) }
    def restore_created_at!; end

    sig { returns(T.untyped) }
    def restore_id!; end

    sig { returns(T.untyped) }
    def restore_name!; end

    sig { returns(T.untyped) }
    def restore_slug!; end

    sig { returns(T.untyped) }
    def restore_updated_at!; end

    sig { returns(T.nilable([T.nilable(::ActiveSupport::TimeWithZone), ::ActiveSupport::TimeWithZone])) }
    def saved_change_to_created_at; end

    sig { returns(T::Boolean) }
    def saved_change_to_created_at?; end

    sig { returns(T.nilable([T.nilable(::Integer), ::Integer])) }
    def saved_change_to_id; end

    sig { returns(T::Boolean) }
    def saved_change_to_id?; end

    sig { returns(T.nilable([T.untyped, T.untyped])) }
    def saved_change_to_name; end

    sig { returns(T::Boolean) }
    def saved_change_to_name?; end

    sig { returns(T.nilable([T.untyped, T.untyped])) }
    def saved_change_to_slug; end

    sig { returns(T::Boolean) }
    def saved_change_to_slug?; end

    sig { returns(T.nilable([T.nilable(::ActiveSupport::TimeWithZone), ::ActiveSupport::TimeWithZone])) }
    def saved_change_to_updated_at; end

    sig { returns(T::Boolean) }
    def saved_change_to_updated_at?; end

    # test
    sig { returns(T.untyped) }
    def slug; end

    # test
    sig { params(value: T.untyped).returns(T.untyped) }
    def slug=(value); end

    sig { returns(T::Boolean) }
    def slug?; end

    sig { returns(T.untyped) }
    def slug_before_last_save; end

    sig { returns(T.untyped) }
    def slug_before_type_cast; end

    sig { returns(T::Boolean) }
    def slug_came_from_user?; end

    sig { returns(T.nilable([T.untyped, T.untyped])) }
    def slug_change; end

    sig { returns(T.nilable([T.untyped, T.untyped])) }
    def slug_change_to_be_saved; end

    sig { returns(T.untyped) }
    def slug_for_database; end

    sig { returns(T.untyped) }
    def slug_in_database; end

    sig { returns(T.nilable([T.untyped, T.untyped])) }
    def slug_previous_change; end

    sig { params(from: T.untyped, to: T.untyped).returns(T::Boolean) }
    def slug_previously_changed?(from: nil, to: nil); end

    sig { returns(T.untyped) }
    def slug_previously_was; end

    sig { returns(T.untyped) }
    def slug_was; end

    sig { returns(T.untyped) }
    def slug_will_change!; end

    sig { returns(T::Boolean) }
    def slugchanged?; end

    # test
    sig { returns(::ActiveSupport::TimeWithZone) }
    def updated_at; end

    # test
    sig { params(value: ::ActiveSupport::TimeWithZone).returns(::ActiveSupport::TimeWithZone) }
    def updated_at=(value); end

    sig { returns(T::Boolean) }
    def updated_at?; end

    sig { returns(T.nilable(::ActiveSupport::TimeWithZone)) }
    def updated_at_before_last_save; end

    sig { returns(::ActiveSupport::TimeWithZone) }
    def updated_at_before_type_cast; end

    sig { returns(T::Boolean) }
    def updated_at_came_from_user?; end

    sig { returns(T.nilable([T.nilable(::ActiveSupport::TimeWithZone), T.nilable(::ActiveSupport::TimeWithZone)])) }
    def updated_at_change; end

    sig { returns(T.nilable([T.nilable(::ActiveSupport::TimeWithZone), T.untyped])) }
    def updated_at_change_to_be_saved; end

    sig { returns(::ActiveSupport::TimeWithZone) }
    def updated_at_for_database; end

    sig { returns(::ActiveSupport::TimeWithZone) }
    def updated_at_in_database; end

    sig { returns(T.nilable([T.nilable(::ActiveSupport::TimeWithZone), T.nilable(::ActiveSupport::TimeWithZone)])) }
    def updated_at_previous_change; end

    sig do
      params(
        from: T.nilable(::ActiveSupport::TimeWithZone),
        to: T.nilable(::ActiveSupport::TimeWithZone)
      ).returns(T::Boolean)
    end
    def updated_at_previously_changed?(from: nil, to: nil); end

    sig { returns(T.nilable(::ActiveSupport::TimeWithZone)) }
    def updated_at_previously_was; end

    sig { returns(T.nilable(::ActiveSupport::TimeWithZone)) }
    def updated_at_was; end

    sig { returns(T.untyped) }
    def updated_at_will_change!; end

    sig { returns(T::Boolean) }
    def updated_atchanged?; end

    sig { returns(T::Boolean) }
    def will_save_change_to_created_at?; end

    sig { returns(T::Boolean) }
    def will_save_change_to_id?; end

    sig { returns(T::Boolean) }
    def will_save_change_to_name?; end

    sig { returns(T::Boolean) }
    def will_save_change_to_slug?; end

    sig { returns(T::Boolean) }
    def will_save_change_to_updated_at?; end
  end

  class ActiveRecord_AssociationRelation < ::ActiveRecord::Relation
    sig { params(other: T.untyped).returns(T.self_type) }
    def and(other); end

    sig { params(args: ::String).returns(T.self_type) }
    def annotate(*args); end

    sig { returns(T.self_type) }
    def async!; end

    sig { params(column_name: ::String).returns(::ActiveRecord::Promise) }
    def async_average(column_name); end

    sig { params(column_name: T.untyped).returns(::ActiveRecord::Promise) }
    def async_count(column_name = nil); end

    sig { returns(::ActiveRecord::Promise) }
    def async_ids; end

    sig { params(column_name: T.untyped).returns(::ActiveRecord::Promise) }
    def async_maximum(column_name); end

    sig { params(column_name: T.untyped).returns(::ActiveRecord::Promise) }
    def async_minimum(column_name); end

    sig { params(column_names: T.untyped).returns(::ActiveRecord::Promise) }
    def async_pick(*column_names); end

    sig { params(column_names: T.untyped).returns(::ActiveRecord::Promise) }
    def async_pluck(*column_names); end

    sig { params(identity_or_column: T.untyped).returns(::ActiveRecord::Promise) }
    def async_sum(identity_or_column = nil); end

    sig { params(column_name: T.any(::String, ::Symbol)).returns(::Numeric) }
    def average(column_name); end

    sig { params(operation: ::Symbol, column_name: T.untyped).returns(T.self_type) }
    def calculate(operation, column_name); end

    sig { params(column_name: T.untyped).returns(::Numeric) }
    def count(column_name = nil); end

    sig { params(other: T.untyped).returns(Tag) }
    def create_with(other); end

    sig { params(value: T::Boolean).returns(T.self_type) }
    def distinct(value = false); end

    sig { params(args: ::Symbol).returns(T.self_type) }
    def eager_load(*args); end

    sig { params(args: ::Symbol).returns(T.self_type) }
    def except(*args); end

    sig { params(records: T::Enumerable[::ActiveRecord::Base]).returns(T.self_type) }
    def excluding(*records); end

    sig { params(conditions: T.untyped).returns(T::Boolean) }
    def exists?(conditions = :none); end

    sig { params(modules: ::Module, block: T.untyped).returns(T.self_type) }
    def extending(*modules, &block); end

    sig { params(association: ::Symbol).returns(T.self_type) }
    def extract_associated(association); end

    sig { returns(T.nilable(Tag)) }
    def fifth; end

    sig { returns(Tag) }
    def fifth!; end

    sig { params(arg: T.untyped).returns(Tag) }
    def find(arg); end

    sig { params(arg: T.untyped, args: T.untyped).returns(T.nilable(Tag)) }
    def find_by(arg, *args); end

    sig { params(arg: T.untyped, args: T.untyped).returns(Tag) }
    def find_by!(arg, *args); end

    sig { params(arg: T.untyped, args: T.untyped).returns(Tag) }
    def find_sole_by(arg, *args); end

    sig { returns(T.nilable(Tag)) }
    def first; end

    sig { returns(Tag) }
    def first!; end

    sig { returns(T.nilable(Tag)) }
    def forty_two; end

    sig { returns(Tag) }
    def forty_two!; end

    sig { returns(T.nilable(Tag)) }
    def fourth; end

    sig { returns(Tag) }
    def fourth!; end

    sig { params(value: T.untyped, subquery_name: T.untyped).returns(T.self_type) }
    def from(value, subquery_name = nil); end

    sig { params(args: T.any(::String, ::Symbol)).returns(T.self_type) }
    def group(*args); end

    sig { params(opts: ::String, rest: ::String).returns(T.self_type) }
    def having(opts, *rest); end

    sig { returns(T::Array[::Integer]) }
    def ids; end

    sig { params(column: T.any(::String, ::Symbol), values: T.untyped).returns(T.self_type) }
    def in_order_of(column, *values); end

    sig { params(record: T.untyped).returns(T::Boolean) }
    def include?(record); end

    sig { params(args: T.untyped).returns(T.self_type) }
    def includes(*args); end

    sig { returns(T.self_type) }
    def invert_where; end

    sig { params(args: T.untyped).returns(T.self_type) }
    def joins(*args); end

    sig { returns(T.nilable(Tag)) }
    def last; end

    sig { returns(Tag) }
    def last!; end

    sig { params(args: T.untyped).returns(T.self_type) }
    def left_joins(*args); end

    sig { params(args: T.untyped).returns(T.self_type) }
    def left_outer_joins(*args); end

    sig { params(value: ::Integer).returns(T.self_type) }
    def limit(value); end

    sig { params(locks: T::Boolean).returns(T.self_type) }
    def lock(locks = true); end

    sig { params(column_name: T.untyped).returns(::Numeric) }
    def maximum(column_name); end

    sig { params(record: T.untyped).returns(T::Boolean) }
    def member?(record); end

    sig { params(other: T.untyped, args: T.untyped).returns(T.self_type) }
    def merge(other, *args); end

    sig { params(column_name: T.untyped).returns(::Numeric) }
    def minimum(column_name); end

    sig { returns(T.self_type) }
    def none; end

    sig { params(value: ::Integer).returns(T.self_type) }
    def offset(value); end

    sig { params(args: ::Symbol).returns(T.self_type) }
    def only(*args); end

    sig { params(args: ::String).returns(T.self_type) }
    def optimizer_hints(*args); end

    sig { params(other: T.untyped).returns(T.self_type) }
    def or(other); end

    sig { params(args: T.untyped).returns(T.self_type) }
    def order(*args); end

    sig { params(column_names: T.untyped).returns(T.untyped) }
    def pick(*column_names); end

    sig { params(column_names: T.untyped).returns(T.untyped) }
    def pluck(*column_names); end

    sig { params(args: T.untyped).returns(T.self_type) }
    def preload(*args); end

    sig { params(locks: T::Boolean).returns(T.self_type) }
    def readonly(locks = true); end

    sig { params(table_names: T.untyped).returns(T.self_type) }
    def references(*table_names); end

    sig { params(args: T.untyped).returns(T.self_type) }
    def regroup(*args); end

    sig { params(args: T.untyped).returns(T.self_type) }
    def reorder(*args); end

    sig { params(args: T.untyped).returns(T.self_type) }
    def reselect(*args); end

    sig { returns(T.self_type) }
    def reverse_order; end

    sig { params(args: T.untyped).returns(T.self_type) }
    def rewhere(*args); end

    sig { returns(T.nilable(Tag)) }
    def second; end

    sig { returns(Tag) }
    def second!; end

    sig { returns(T.nilable(Tag)) }
    def second_to_last; end

    sig { returns(Tag) }
    def second_to_last!; end

    sig { params(args: T.untyped).returns(T.self_type) }
    def select(*args); end

    sig { returns(Tag) }
    def sole; end

    sig { params(value: T::Boolean).returns(T.self_type) }
    def strict_loading(value = true); end

    sig { params(other: T.untyped).returns(T::Boolean) }
    def structurally_compatible?(other); end

    sig { params(initial_value_or_column: ::Integer).returns(T.self_type) }
    def sum(initial_value_or_column = 0); end

    sig { params(limit: ::Integer).returns(T::Array[Tag]) }
    def take(limit = nil); end

    sig { returns(Tag) }
    def take!; end

    sig { returns(T.nilable(Tag)) }
    def third; end

    sig { returns(Tag) }
    def third!; end

    sig { returns(T.nilable(Tag)) }
    def third_to_last; end

    sig { returns(Tag) }
    def third_to_last!; end

    sig { params(name: T.untyped).returns(T.self_type) }
    def uniq!(name); end

    sig { params(args: T.untyped).returns(T.self_type) }
    def unscope(*args); end

    sig { params(args: T.untyped).returns(T.self_type) }
    def where(*args); end

    sig { params(args: T.untyped).returns(T.self_type) }
    def with(*args); end

    sig { params(records: T.untyped).returns(T.self_type) }
    def without(*records); end
  end
end
